---
title: "R Notebook"
output: html_document
---

```{r,warning = FALSE}
library(drpm)
library(salso)

# preparation
source("include.R") # for having df_agri
source("plot functions/plotter.R")

sites = data.frame(
	longitude = unique(df_weekly$Longitude), 
	latitude = unique(df_weekly$Latitude))
```

better to leave this alone (less buggy but dont know why).
```{r}
source("include_clusters_functions.R")
```


# create a pm10 table (station x time)
```{r}
stations = unique(df_weekly$IDStations)
y=data.frame()

for(st in stations){
  y_we_pm10=cbind(as.data.frame(st),t(df_weekly[which(df_weekly$IDStations==st),"AQ_pm10"]))
  y=rbind(y,y_we_pm10)
}

rownames(y) = NULL
colnames(y)<- c("id",paste0("w", 1:53))
df_weekly
y
```


# Trend plots
```{r}
hist(df_weekly$AQ_pm10)
cat(extrema(df_weekly$AQ_pm10))
```

```{r}
yred=y[,2:54]
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
 	  } 
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
}
```

```{r}
cols = colora(105,56,show=F)
chosen_variable_name = "AQ_pm10"

trendYearStation_week <- function(file_name){

	data_from_to = df_weekly
	len_time = 54
	
	chosen_variable = (data_from_to[,chosen_variable_name])

	# Crea il grafico ggplot
	station_trend <- ggplot(data_from_to,aes(x = week, 
												 y = AQ_pm10,
												 group=IDStations, 
												 color = as.factor(IDStations))) +
		
		geom_line(show.legend = FALSE) +
		labs(x = "Stations", y = chosen_variable_name, title = "Year: 2018 all stations") +
		ylim(range(na.omit(chosen_variable))) +
		scale_color_manual(values = cols) +
		theme_bw()+
		theme(panel.grid = element_blank()) +
		guides(color = guide_legend())+
		labs(x="week")
	
	len_time = (len_time%/%5)
	return(trend_animator(file_name,station_trend, data_from_to$week,len_time))
}
trendYearStation_week("None")
```



# Model fit
```{r}
time_span = 1:5 # low time span for quick testing, real one will be 1:53
tempo_inizio <- Sys.time()

drpm1 <- drpm_fit(y[,1+time_span], # use log trasnformed values, as we should
# drpm1 <- drpm_fit(exp(y[,-1])[,1:20], # use original values, but should be a wrong approach
		 s_coords = sites,
         M=1,
         initial_partition = NULL,
         starting_alpha = 0.5,
         unit_specific_alpha = FALSE,
         time_specific_alpha = TRUE,
         alpha_0=FALSE,
         eta1_0=FALSE, # TRUE?
         phi1_0=FALSE,
         modelPriors=c(0,100^2,1,1,1,1),

         alphaPriors=rbind(c(1,1)), # if time_specific_alpha == TRUE
         # alphaPriors=matrix(rep(c(1,1),105),105,2), # if unit_specific_alpha == TRUE
         # alphaPriors=matrix(rep(c(1,1),105),105,2), # if both the above are TRUE

         simpleModel = 0,
         theta_tau2 = c(0, 2),
         SpatialCohesion=4,
         cParms=c(0, 1, 2, 1),
         mh=c(0.5, 1, 0.1, 0.1, 0.1),
         verbose=TRUE,

         # draws=1100,burn=100,thin=1) # quick one
         draws=6100,burn=500,thin=2) # a bit more serious seriou one
         # draws=10100,burn=1500,thin=5) # more serious one

tempo_fine <- Sys.time()
```

```{r}
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n",
				 differenza_tempo, "seconds, ie\n",
				 as.numeric(differenza_tempo,units="mins"), "minutes, ie\n",
				 as.numeric(differenza_tempo,units="hours"), "hours\n"))
```



```{r}
names(drpm1)
size(drpm1$Si)
# questa cos ha le simulazioni dei cluster assegnati
# ha dimensione 53 righe (o meno se fittiamo su meno tempi per dei test),
# poi ha 105 colonne, e 1000 "volte", perché
# - per ognuna delle 1000 iterazioni delle MCMC
# - dà i cluster assegnati dalla simulazione per le stazioni in quella simulazione
```


```{r}
# the row dimensione will be 53, for now is time_span limit (like 5)
cat("Si     size = ",size(drpm1$Si),"\n")
cat("gamma  size = ",size(drpm1$gamma),"\n")
cat("mu     size = ",size(drpm1$mu),"\n")
cat("sig2   size = ",size(drpm1$sig2),"\n")
cat("alpha  size = ",size(drpm1$alpha),"\n")
cat("theta  size = ",size(drpm1$theta),"\n")
cat("tau2   size = ",size(drpm1$tau2),"\n")
cat("eta1   size = ",size(drpm1$eta1),"\n")
cat("phi0   size = ",size(drpm1$phi0),"\n")
cat("phi1   size = ",size(drpm1$phi1),"\n")
cat("lam2   size = ",size(drpm1$lam2),"\n")
cat("llike  size = ",size(drpm1$llike),"\n")
cat("fitted size = ",size(drpm1$fitted),"\n")
```



# Trace plots?
```{r}
sampled_station = floor(runif(1,0,105))
```

## Si
Sparse dots means that the algorithm is confused about which partition attribute to that station.
But for now the sparse dots are few, and in the initial iterations of the MCMC, so this seems good.
```{r}
for (time in time_span){
	plot(drpm1$Si[time,sampled_station,],type="l",
		 main=bquote("Trace plot of partition at time (=week) " * .(time) * 
		 				" - station " * .(sampled_station)),
		 xlab = "MCMC iterations",ylab="values")
}
```

## gamma
Gamma is not really a parameter but the collection of the alphas.
So it is normal that gamma does not have a "good" trace plot.

```{r}
for (time in time_span){
	plot(drpm1$gamma[time,sampled_station,],type="l",
		 main=bquote("Trace plot of " * gamma * " at time (=week) " * .(time-1) * 
		 				" - station " * .(sampled_station)),
		 xlab = "MCMC iterations",ylab="values")
}
```

## mu
```{r}
for (time in time_span){
	plot(drpm1$mu[time,sampled_station,],type="l",
		 main=bquote("Trace plot of " * mu * " at time (=week) " * .(time) * 
		 				" - station " * .(sampled_station)),
		 xlab = "MCMC iterations",ylab="values")
}
```

## sigma2
```{r}
for (time in time_span){
	plot(drpm1$sig2[time,sampled_station,],type="l",
		 main=bquote("Trace plot of "* sigma^2 * " at time (=week) " * .(time) * 
		 				" - station " * .(sampled_station)),
		 xlab = "MCMC iterations",ylab="values")
}

```

## alpha
```{r}
sampled_station = floor(runif(1,0,105))

if(len(size(drpm1$alpha))==2){ # alpha is only time dependent
	for (time in time_span){
	plot(drpm1$alpha[,time],type="l",
		 main=bquote("Trace plot of " * alpha[.(time)] * " - station " * .(sampled_station)),
		 xlab = "MCMC iterations",ylab="values")	
	}
}

if(len(size(drpm1$alpha))==3){ # alpha is time dependent and unit dependent
	for (time in time_span){
	plot(drpm1$alpha[time,sampled_station,],type="l",
		 main=bquote("Trace plot of " * alpha[.(time-1)] * " - station" * .(sampled_station)),
		 xlab = "MCMC iterations",ylab="values")
	}
}
```



# Map cluster plots
## dataframe for clusters
```{r,warning=FALSE}
df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
for(time in time_span){

	salso_out <- salso(t(drpm1$Si[time,,]),loss="binder")
	
	df_temp = data.frame(
		Longitude = sites$longitude,
		Latitude = sites$latitude,
		clusters = salso_out[1:105]
	)
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
}
```



# Clusters distribution

Sembra ci siano molti cluster piccoli, quindi forse occorre capire le prior/i parametri di drpm_fit per aggiustare questo fenomeno.
Update: dopo la log transformazione non più. Ma anzi ora forse ce ne sono troppi pochi di cluster.

```{r}
# choose wisely
# this will be from now on the color palette decision
cols = colora(5,"div")[-2] # togliamo il giallino
```


## continuos
```{r,warning=FALSE}
clusters_old = NULL
for(time in time_span){

	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	clusters_now = mode_correct_clusters(clusters_old,clusters_now)
	df_cluster_cut$clusters = clusters_now
	
	p = get_hist_continuos_plot(df_cluster_cut,verbose=1)
	
	print(p)
	clusters_old = clusters_now
} # end for(time in eccc)
```

## histogram v1 - no fill
```{r,warning=FALSE}
clusters_old = NULL
for(time in time_span){

	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	clusters_now = mode_correct_clusters(clusters_old,clusters_now)
	df_cluster_cut$clusters = clusters_now
	
	p = get_hist_color_plot(df_cluster_cut)
	
	print(p)
	clusters_old = clusters_now
} # end for(time in eccc)
```

## histogram v2 - fill
```{r,warning=FALSE}
clusters_old = NULL
for(time in time_span){

	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	clusters_now = mode_correct_clusters(clusters_old,clusters_now)
	df_cluster_cut$clusters = clusters_now
	
	p = get_hist_fill_plot(df_cluster_cut)
	
	print(p)
	clusters_old = clusters_now
} # end for(time in eccc)
```



# Plot for time 1
```{r}
df_cluster_cut = df_cluster[df_cluster$Time==time,]
p  <-  DefaultPlot()+
	geom_point(data = df_cluster_cut, aes(x = Longitude, y = Latitude, color = factor(clusters)), size = 3)+
	labs(title = "Cluster map")+
		guides(color = guide_legend(title = "Clusters"))

p
```



# Save png(s) for animation
```{r}
for( time in time_span){
	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	
	p  <-  DefaultPlot()+
		geom_point(data = df_cluster_cut, aes(x = Longitude, y = Latitude, 
											  color = factor(clusters)), size = 3)+
		labs(title = "Cluster map")+
		guides(color = guide_legend(title = "Clusters"))
	
	ggsave(
	  paste0("cluster_plots/cluster_time-",time,".png"),
	  plot = p
	)
}

```


# Fede: graph cluster plot

## Version 2 - final
all the functions are in the include_clusters_function. Here is the code to plot.
```{r}
# cols chosen previously
clusters_old = NULL
for(time in time_span){
	cat(crayon::red("Time",time,"\n"))
	
	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	clusters_now = mode_correct_clusters(clusters_old,clusters_now)
	df_cluster_cut$clusters = clusters_now
	
	q = get_graph_plot(df_cluster_cut)
	
	print(q)
	clusters_old = clusters_now
}
```
Forse possiamo fare insieme questa mappa con quella degli istogrammi sopra.
Così ad ogni istante temporale, e poi nell'animazione, vediamo sia i cluster sia quanto sono diversi in termini di "densità".

Del tipo
```{r}
library(gridExtra)

clusters_old = NULL
for(time in time_span){

# GRAPH #######################
cat(crayon::red("Time",time,"\n"))
df_cluster_cut = df_cluster[df_cluster$Time==time,]
clusters_now = df_cluster_cut$clusters
clusters_now = mode_correct_clusters(clusters_old,clusters_now)
df_cluster_cut$clusters = clusters_now
q_graph = get_graph_plot(df_cluster_cut)

# HIST #######################
# by hand as we have to remove the legend here, while the function produces it
n_clusters = max(clusters_now)
ycurrent = y[,paste0("w",time)]
clust_vals = clusters_now[1:105]
df_temp = data.frame(clusters=clust_vals,ycurrent=ycurrent)
p = ggplot(df_temp, aes(ycurrent,
						color = cols[clust_vals]
						))+
	geom_histogram(alpha=0.5,
				   fill="white",
				   position="identity")+ 
	ggtitle(paste("Time",time))+
	# guides(color = guide_legend(title = "Clusters"))+
	theme_bw()+
	theme(legend.position = "none")+
	scale_color_identity(guide="legend",labels=paste0("cl",1:max(clust_vals)),
						breaks=cols[1:max(clust_vals)])+
	xlab("log(PM10) values")+
	xlim(c(0,5))
	# xlim(extrema(df_weekly$AQ_pm10))
p_hist = p

grid.arrange(q_graph, p_hist, ncol=2,widths=c(1.5,1))
clusters_old = clusters_now
}
```



