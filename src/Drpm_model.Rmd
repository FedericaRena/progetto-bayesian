---
title: "R Notebook"
output: html_document
---

```{r,warning = FALSE}
library(drpm)
library(salso)

# preparation
source("include.R") # for having df_agri
source("plot functions/plotter.R")

sites = data.frame(
	longitude = unique(df_weekly$Longitude), 
	latitude = unique(df_weekly$Latitude))
```

better to leave this alone (less buggy but dont know why).
```{r}
source("include_clusters_functions.R")
```


# create a pm10 table (station x time)
```{r}
stations = unique(df_weekly$IDStations)
y=data.frame()

for(st in stations){
  y_we_pm10=cbind(as.data.frame(st),t(df_weekly[which(df_weekly$IDStations==st),"AQ_pm10"]))
  y=rbind(y,y_we_pm10)
}

rownames(y) = NULL
colnames(y)<- c("id",paste0("w", 1:53))
df_weekly
y
```


# Trend plots
```{r}
hist(df_weekly$AQ_pm10)
cat(extrema(df_weekly$AQ_pm10))
```

```{r}
yred=y[,2:54]
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
 	  } 
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
}
```

```{r}
cols = colora(105,56,show=F)
chosen_variable_name = "AQ_pm10"

trendYearStation_week <- function(file_name){

	data_from_to = df_weekly
	len_time = 54
	
	chosen_variable = (data_from_to[,chosen_variable_name])

	# Crea il grafico ggplot
	station_trend <- ggplot(data_from_to,aes(x = week, 
												 y = AQ_pm10,
												 group=IDStations, 
												 color = as.factor(IDStations))) +
		
		geom_line(show.legend = FALSE) +
		labs(x = "Stations", y = chosen_variable_name, title = "Year: 2018 all stations") +
		ylim(range(na.omit(chosen_variable))) +
		scale_color_manual(values = cols) +
		theme_bw()+
		theme(panel.grid = element_blank()) +
		guides(color = guide_legend())+
		labs(x="week")
	
	len_time = (len_time%/%5)
	return(trend_animator(file_name,station_trend, data_from_to$week,len_time))
}
trendYearStation_week("None")
```



# Model fit
```{r}
time_span = 1:5 # low time span for quick testing, real one will be 1:53

drpm1 <- drpm_fit(y[,1+time_span], # use log trasnformed values, as we should
# drpm1 <- drpm_fit(exp(y[,-1])[,1:20], # use original values, but should be a wrong approach
		 s_coords = sites,
         M=1,
         initial_partition = NULL,
         starting_alpha = 0.5,
         unit_specific_alpha = FALSE,
         time_specific_alpha = TRUE,
         alpha_0=FALSE,
         eta1_0=TRUE,
         phi1_0=FALSE,
         modelPriors=c(0,100^2,1,1,1,1),

         alphaPriors=rbind(c(1,1)), # if time_specific_alpha == TRUE
         # alphaPriors=matrix(rep(c(1,1),105),105,2), # if unit_specific_alpha == TRUE
         # alphaPriors=matrix(rep(c(1,1),105),105,2), # if both the above are TRUE

         simpleModel = 0,
         theta_tau2 = c(0, 2),
         SpatialCohesion=4,
         cParms=c(0, 1, 2, 1),
         mh=c(0.5, 1, 0.1, 0.1, 0.1),
         verbose=TRUE,

         draws=1100,burn=100,thin=1) # quick one
         # draws=10100,burn=100,thin=2) # more serious one
```



```{r}
# the row dimensione will be 53, for now is time_span limit (like 5)
cat("Si     size = ",size(drpm1$Si),"\n")
cat("gamma  size = ",size(drpm1$gamma),"\n")
cat("mu     size = ",size(drpm1$mu),"\n")
cat("sig2   size = ",size(drpm1$sig2),"\n")
cat("alpha  size = ",size(drpm1$alpha),"\n")
cat("theta  size = ",size(drpm1$theta),"\n")
cat("tau2   size = ",size(drpm1$tau2),"\n")
cat("eta1   size = ",size(drpm1$eta1),"\n")
cat("phi0   size = ",size(drpm1$phi0),"\n")
cat("phi1   size = ",size(drpm1$phi1),"\n")
cat("lam2   size = ",size(drpm1$lam2),"\n")
cat("llike  size = ",size(drpm1$llike),"\n")
cat("fitted size = ",size(drpm1$fitted),"\n")
```


```{r}
names(drpm1)
size(drpm1$Si)
# questa cos ha le simulazioni dei cluster assegnati
# ha dimensione 53 righe (o meno se fittiamo su meno tempi per dei test),
# poi ha 105 colonne, e 1000 "volte", perché
# - per ognuna delle 1000 iterazioni delle MCMC
# - dà i cluster assegnati dalla simulazione per le stazioni in quella simulazione
```


# Trace plots?
```{r}
example_unit = 10

if(len(size(drpm1$alpha))==2){ # alpha is only time dependent
	for (time in time_span){
	plot(drpm1$alpha[,time],type="l",
		 main=bquote("Trace plot of " * alpha[.(time-1)]),
		 xlab = "MCMC iterations",ylab="values")	
	}
}

if(len(size(drpm1$alpha))==3){ # alpha is time dependent and unit dependent
	for (time in time_span){
	plot(drpm1$alpha[time,example_unit,],type="l",
		 main=bquote("Trace plot of " * alpha[.(time-1)] * " for unit" * .(example_unit)),
		 xlab = "MCMC iterations",ylab="values")
	}
}


```


# Clusters distribution
Sembra ci siano molti cluster piccoli, quindi forse occorre capire le prior/i parametri di drpm_fit per aggiustare questo fenomeno.
Update: dopo la log transformazione non più. Ma anzi ora forse ce ne sono troppi pochi di cluster.

```{r,warning=FALSE}
for(time in time_span){

	salso_out <- salso(t(drpm1$Si[time,,]),loss="binder")
		
	n_clusters = max(salso_out)
	ycurrent = y[,paste0("w",time)]
	cat(crayon::red("Time",time,"\n"))
	for (cl in 1:n_clusters){

		cat("Cluster",cl,"- size",length(ycurrent[which(salso_out==cl)]),
			"- mean",mean(ycurrent[which(salso_out==cl)]),"\n")

	}

	clust_vals = salso_out[1:105]
	df_temp = data.frame(clust_vals=clust_vals,ycurrent=ycurrent)

	# per ora stiamo lavorando sui valori del dataset,
	# ma dobbiamo ricordarci che li dobbiamo log-trasformare in realtà

	pad = 2	
	p = ggplot(df_temp, aes(ycurrent, fill = factor(clust_vals))) +

		scale_fill_manual(values = colora(n_clusters,77,0),name="Cluster")+
		geom_density(alpha = 0.3)+
		ggtitle(paste("Time",time))+
		theme_classic()+
		xlim(extrema(ycurrent)+c(-pad,pad))
	print(p)

} # end for(time in eccc)
```


"pochi ma buoni per ora"
Cioè almeno nel mio notebook sono usciti sempre due soli cluster ma ben divisi



# Map cluster plots
## dataframe for clusters
```{r,warning=FALSE}
df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
for(time in time_span){

	salso_out <- salso(t(drpm1$Si[time,,]),loss="binder")
	
	df_temp = data.frame(
		Longitude = sites$longitude,
		Latitude = sites$latitude,
		clusters = salso_out[1:105]
	)
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
}
```


## Plot for time 1
```{r}
df_cluster_cut = df_cluster[df_cluster$Time==time,]
p  <-  DefaultPlot()+
	geom_point(data = df_cluster_cut, aes(x = Longitude, y = Latitude, color = factor(clusters)), size = 3)+
	labs(title = "Cluster map")+
		guides(color = guide_legend(title = "Clusters"))

p
```



## Save png(s) for animation
```{r}
for( time in time_span){
	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	
	p  <-  DefaultPlot()+
		geom_point(data = df_cluster_cut, aes(x = Longitude, y = Latitude, 
											  color = factor(clusters)), size = 3)+
		labs(title = "Cluster map")+
		guides(color = guide_legend(title = "Clusters"))
	
	ggsave(
	  paste0("cluster_plots/cluster_time-",time,".png"),
	  plot = p
	)
}

```



# Fede: graph cluster plot

## Version 2 - final
all the functions are in the include_clusters_function. Here is the code to plot.
```{r}
cols = colora(5,"div") # divergent palette

clusters_old = NULL
for(time in time_span[1:4]){
# time = 4
cat(crayon::red("Time",time,"\n"))
df_cluster_cut = df_cluster[df_cluster$Time==time,]
clusters_now = df_cluster_cut$clusters
clusters_now = mode_correct_clusters(clusters_old,clusters_now)
df_cluster_cut$clusters = clusters_now

edges_list = assemble_edges_list(clusters_now)

p  <-  DefaultPlot()+
	geom_point(data = df_cluster_cut, aes(x = Longitude, y = Latitude,
										  # color = cols[factor(clusters)]), size = 2)+
										  color = cols[clusters_now]), size = 2)+
	labs(title = paste("Cluster map - time",time))

q = p
for(cl in 1:len(edges_list)){
	edges_to_plot = edges_list[[cl]]
	q = q + geom_segment(aes(x = x, y = y, xend = xend, yend = yend,
					 color = cols[as.numeric(cluster)]),
					 # color = paste0("cl",cl)),
				 linewidth=1.2,
				 data = edges_to_plot,show.legend = TRUE)+
		guides(color = guide_legend(title = "Clusters"))
}

q = q +
	scale_colour_identity(guide="legend",labels=paste0("cl",1:len(edges_list)),
						  breaks=cols[1:len(edges_list)])

print(q)
clusters_old = clusters_now
}
```


```{r}
ggplot(luv_colours, aes(u, v)) +
  geom_point(aes(colour = col), size = 3) +
  scale_color_identity() +
  coord_fixed()

df <- data.frame(
  x = 1:4,
  y = 1:4,
  colour = c("AAA"="red", "B"="green", "BL"="blue", "YE"="yellow")
)
ggplot(df, aes(x, y)) + geom_tile(aes(fill = colour))
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = colour)) +
  scale_fill_identity()

# To get a legend guide, specify guide = "legend"
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = colour)) +
  scale_fill_identity(guide = "legend")
# But you'll typically also need to supply breaks and labels:
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = colour)) +
  scale_fill_identity("trt", labels = letters[1:4], breaks = df$colour,
  guide = "legend")

# cyl scaled to appropriate size
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(size = cyl))

# cyl used as point size
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(size = cyl)) +
  scale_size_identity()
```


