---
title: "R Notebook"
output: html_document
---

```{r,warning = FALSE}
library(drpm)
library(salso)

# preparation
source("include.R") # for having df_agri
source("plot functions/plotter.R")

sites = data.frame(
	longitude = unique(df_weekly$Longitude), 
	latitude = unique(df_weekly$Latitude))
```

better to leave this alone (less buggy but dont know why).
```{r}
source("include_clusters_functions.R")
```


# create a pm10 table (station x time)
```{r}
stations = unique(df_weekly$IDStations)
y=data.frame()

for(st in stations){
  y_we_pm10=cbind(as.data.frame(st),t(df_weekly[which(df_weekly$IDStations==st),"AQ_pm10"]))
  y=rbind(y,y_we_pm10)
}

rownames(y) = NULL
colnames(y)<- c("id",paste0("w", 1:53))
df_weekly
y
```


# Trend plots
```{r}
hist(df_weekly$AQ_pm10)
cat(extrema(df_weekly$AQ_pm10))
```

```{r}
yred=y[,2:54]
cols = colora(size(yred)[1],56,0)
for(i in 1:size(yred)[1]){
   if(i==1){
     plot(1:size(yred)[2],yred[i,],col=cols[i],ylim=extrema(yred),type='l',xlab='weeks',ylab='pm10')
 	  } 
	  else{
		  lines(1:size(yred)[2],yred[i,],col=cols[i])
	  }
}
```

```{r}
cols = colora(105,56,show=F)
chosen_variable_name = "AQ_pm10"

trendYearStation_week <- function(file_name){

	data_from_to = df_weekly
	len_time = 54
	
	chosen_variable = (data_from_to[,chosen_variable_name])

	# Crea il grafico ggplot
	station_trend <- ggplot(data_from_to,aes(x = week, 
												 y = AQ_pm10,
												 group=IDStations, 
												 color = as.factor(IDStations))) +
		
		geom_line(show.legend = FALSE) +
		labs(x = "Stations", y = chosen_variable_name, title = "Year: 2018 all stations") +
		ylim(range(na.omit(chosen_variable))) +
		scale_color_manual(values = cols) +
		theme_bw()+
		theme(panel.grid = element_blank()) +
		guides(color = guide_legend())+
		labs(x="week")
	
	len_time = (len_time%/%5)
	return(trend_animator(file_name,station_trend, data_from_to$week,len_time))
}
trendYearStation_week("None")
```



# Model fit

## Scaling/Centering update
```{r}
time_span = 1:10 # low time span for quick testing, real one will be 1:53

### authors suggested to/did scale the spatial locations and also centered the observations
y_fit = y[,1+time_span]
y_fit = scale(y_fit,center=TRUE, scale=FALSE)
y

medie = apply(y[,1+time_span],2,mean)
head(t(t(y[,1+time_span])-medie)) # scale hand computed, to check

y_fit = data.frame(y_fit)
colnames(y_fit) = colnames(y)[1+time_span]

y_fit

### and for the scaling of spatial locations
std_sites = sites
	
smn <- apply(std_sites,2,mean)
ssd <- apply(std_sites,2,sd)
std_sites <- t((t(std_sites) - smn)/ssd)

sites
std_sites = data.frame(std_sites)
colnames(std_sites) = colnames(sites)
std_sites
```


```{r}
tempo_inizio <- Sys.time()
cat("mcmc iter = 0 ===========================================\n",date(),"\n")
drpm1 <- drpm_fit(y=y_fit, 
		 s_coords = std_sites,
         M=1,
         initial_partition = NULL,
         starting_alpha = 0.5,
         unit_specific_alpha = FALSE,
         time_specific_alpha = FALSE, # meaning a bit ambiguos
		# Ok after experimenting it means that:
		# - if true we let alpha be a param that changes over time. 
		#	At time 1 we have a chain with some behaviour, 
		#	at time 2 another chain with another behaviour, ecc
		# - if false we instead fix alpha, ie all chains of all times
		#	will be the same, as they refer to the same parameter estimation
		# The authors in their tests set it to false, ie the fixed alpha

         alpha_0=FALSE,
         eta1_0=FALSE,
         phi1_0=FALSE,

         # modelPriors=c(0,100^2,1,1,1,1), # original default one
         modelPriors=c(0,100,10,5,5,2,2,1), # author suggestion/used one

         alphaPriors=rbind(c(1,1)), # if time_specific_alpha == TRUE
         # alphaPriors=matrix(rep(c(1,1),105),105,2), # if unit_specific_alpha == TRUE
         # alphaPriors=matrix(rep(c(1,1),105),105,2), # if both the above are TRUE

         simpleModel = 0,
         theta_tau2 = c(0, 2), # only used if simpleModel=1

         # SpatialCohesion=3, # auxiliary similarity
         SpatialCohesion=4, # double dipper similarity, default one

         cParms=c(0, 1, 2, 1),
		
         # mh=c(0.5, 1, 0.1, 0.1, 0.1), # default one
		 mh=c(1,1, 1, 0.1, 0.1), # author suggestion/used one

         verbose=TRUE,

         draws=1100,burn=100,thin=1) # quick one
         # draws=9000,burn=1000,thin=2) # a bit more serious seriou one
         # draws=10000,burn=2000,thin=10) # really serious one
         # draws=20000,burn=8000,thin=10) # more serious one

tempo_fine <- Sys.time()
differenza_tempo <- tempo_fine - tempo_inizio
cat(crayon::cyan("Fit took:\n"))
print(round(differenza_tempo,digits = 4))

cat(crayon::blue("That was for fitting",max(time_span),"time steps.\nSo for fitting all 53 weeks the expected time with these parameters will be:\n"))
print(round(differenza_tempo/max(time_span)*53,digits=4))
```




```{r}
names(drpm1)
size(drpm1$Si)
# questa cos ha le simulazioni dei cluster assegnati
# ha dimensione 53 righe (o meno se fittiamo su meno tempi per dei test),
# poi ha 105 colonne, e 1000 "volte", perché
# - per ognuna delle 1000 iterazioni delle MCMC
# - dà i cluster assegnati dalla simulazione per le stazioni in quella simulazione
```


```{r}
# the row dimensione will be 53, for now is time_span limit (like 5)
cat("Si     size = ",size(drpm1$Si),"\n")
cat("gamma  size = ",size(drpm1$gamma),"\n")
cat("mu     size = ",size(drpm1$mu),"\n")
cat("sig2   size = ",size(drpm1$sig2),"\n")
cat("alpha  size = ",size(drpm1$alpha),"\n")
cat("theta  size = ",size(drpm1$theta),"\n")
cat("tau2   size = ",size(drpm1$tau2),"\n")
cat("eta1   size = ",size(drpm1$eta1),"\n")
cat("phi0   size = ",size(drpm1$phi0),"\n")
cat("phi1   size = ",size(drpm1$phi1),"\n")
cat("lam2   size = ",size(drpm1$lam2),"\n")
cat("llike  size = ",size(drpm1$llike),"\n")
cat("fitted size = ",size(drpm1$fitted),"\n")
```



# Trace plots?
```{r}
sampled_station = floor(runif(1,1,105))
cat("sampled_station =",sampled_station,"- that is station called",unique(df_weekly$IDStations)[sampled_station])
sampled_station_name = unique(df_weekly$IDStations)[sampled_station]

```

## alpha
```{r}
if(len(size(drpm1$alpha))==2){ # alpha is only time dependent
	for (time in time_span){
	plot(drpm1$alpha[,time],type="l",
		 main=bquote("Trace plot of " * alpha[.(time)] * " - station " * .(sampled_station_name)),
		 xlab = "MCMC iterations",ylab="values")	
	}
}

if(len(size(drpm1$alpha))==3){ # alpha is time dependent and unit dependent
	for (time in time_span){
	plot(drpm1$alpha[time,sampled_station,],type="l",
		 main=bquote("Trace plot of " * alpha[.(time-1)] * " - station" * .(sampled_station_name)),
		 xlab = "MCMC iterations",ylab="values")
	}
}
```

## Si
Sparse dots means that the algorithm is confused about which partition attribute to that station.
But for now the sparse dots are few, and in the initial iterations of the MCMC, so this seems good.
```{r}
for (time in time_span){
	plot(drpm1$Si[time,sampled_station,],type="l",
		 main=bquote("Trace plot of partition at time (=week) " * .(time) * 
		 				" - station " * .(sampled_station_name)),
		 xlab = "MCMC iterations",ylab="values")
}
```

## gamma
Gamma is not really a parameter but the collection of the alphas.
So we dont care abouth her trace plot.

```{r}
for (time in time_span){
	plot(drpm1$gamma[time,sampled_station,],type="l",
		 main=bquote("Trace plot of " * gamma * " at time (=week) " * .(time-1) * 
		 				" - station " * .(sampled_station_name)),
		 xlab = "MCMC iterations",ylab="values")
}
```

## mu
```{r}
for (time in time_span){
	plot(drpm1$mu[time,sampled_station,],type="l",
		 main=bquote("Trace plot of " * mu * " at time (=week) " * .(time) * 
		 				" - station " * .(sampled_station_name)),
		 xlab = "MCMC iterations",ylab="values")
}
```

## sigma2
```{r}
for (time in time_span){
	plot(drpm1$sig2[time,sampled_station,],type="l",
		 main=bquote("Trace plot of "* sigma^2 * " at time (=week) " * .(time) * 
		 				" - station " * .(sampled_station_name)),
		 xlab = "MCMC iterations",ylab="values")
}

```




# Map cluster plots
## dataframe for clusters
```{r,warning=FALSE}
df_cluster = data.frame(Longitude=c(),Latitude=c(),values=c(),clusters=c(),Time=c())
for(time in time_span){

	salso_out <- salso(t(drpm1$Si[time,,]),loss="binder")
	
	df_temp = data.frame(
		Longitude = sites$longitude,
		Latitude = sites$latitude,
		clusters = salso_out[1:105]
	)
	df_temp$Time = rep(time,dim(df_temp)[1])
	df_cluster = rbind(df_cluster,df_temp)
}
```



# Clusters distribution

Sembra ci siano molti cluster piccoli, quindi forse occorre capire le prior/i parametri di drpm_fit per aggiustare questo fenomeno.
Update: dopo la log transformazione non più. Ma anzi ora forse ce ne sono troppi pochi di cluster.

```{r}
# choose wisely
# this will be from now on the color palette decision
cols = colora(12,"div")[-2] # togliamo il giallino
```


## continuos
```{r,warning=FALSE}
clusters_old = NULL
for(time in time_span){

	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	clusters_now = mode_correct_clusters(clusters_old,clusters_now)
	df_cluster_cut$clusters = clusters_now
	
	p = get_hist_continuos_plot(df_cluster_cut,verbose=1)
	
	print(p)
	clusters_old = clusters_now
} # end for(time in eccc)
```

## histogram v1 - no fill
```{r,warning=FALSE}
clusters_old = NULL
for(time in time_span){

	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	clusters_now = mode_correct_clusters(clusters_old,clusters_now)
	df_cluster_cut$clusters = clusters_now
	
	p = get_hist_color_plot(df_cluster_cut)
	
	print(p)
	clusters_old = clusters_now
} # end for(time in eccc)
```

## histogram v2 - fill
```{r,warning=FALSE}
clusters_old = NULL
for(time in time_span){

	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	clusters_now = mode_correct_clusters(clusters_old,clusters_now)
	df_cluster_cut$clusters = clusters_now
	
	p = get_hist_fill_plot(df_cluster_cut)
	
	print(p)
	clusters_old = clusters_now
} # end for(time in eccc)
```

## boxplot
```{r}
clusters_old = NULL
for(time in time_span){

	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	clusters_now = mode_correct_clusters(clusters_old,clusters_now)
	df_cluster_cut$clusters = clusters_now
	
	p = get_boxplot_plot(df_cluster_cut)
	
	print(p)
	clusters_old = clusters_now
} # end for(time in eccc)
```



# Plot for time 1
```{r}
df_cluster_cut = df_cluster[df_cluster$Time==time,]
p  <-  DefaultPlot()+
	geom_point(data = df_cluster_cut, aes(x = Longitude, y = Latitude, color = factor(clusters)), size = 3)+
	labs(title = "Cluster map")+
		guides(color = guide_legend(title = "Clusters"))

p
```



# Save png(s) for animation
```{r}
save_pngs = 0

if(save_pngs==1){
for( time in time_span){
	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	
	p  <-  DefaultPlot()+
		geom_point(data = df_cluster_cut, aes(x = Longitude, y = Latitude, 
											  color = factor(clusters)), size = 3)+
		labs(title = "Cluster map")+
		guides(color = guide_legend(title = "Clusters"))
	
	ggsave(
	  paste0("cluster_plots/cluster_time-",time,".png"),
	  plot = p
	)
}
} else {
	cat("Not saving pngs for now.")
}
```


# Fede: graph cluster plot

## Version 2 - final
all the functions are in the include_clusters_function. Here is the code to plot.
```{r}
# cols chosen previously
clusters_old = NULL
for(time in time_span){
	cat(crayon::red("Time",time,"\n"))
	
	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	# clusters_now = mode_correct_clusters(clusters_old,clusters_now,very_verbose = 0)
	df_cluster_cut$clusters = clusters_now
	
	q = get_graph_plot(df_cluster_cut)
	
	print(q)
	clusters_old = clusters_now
}
```



```{r}
# cols chosen previously
clusters_old = NULL
for(time in time_span){
	cat(crayon::red("Time",time,"\n"))
	
	df_cluster_cut = df_cluster[df_cluster$Time==time,]
	clusters_now = df_cluster_cut$clusters
	clusters_now = mode_correct_clusters(clusters_old,clusters_now,very_verbose = 0)
	df_cluster_cut$clusters = clusters_now
	
	q = get_graph_plot(df_cluster_cut)
	
	print(q)
	clusters_old = clusters_now
}
```
Forse possiamo fare insieme questa mappa con quella degli istogrammi sopra.
Così ad ogni istante temporale, e poi nell'animazione, vediamo sia i cluster sia quanto sono diversi in termini di "densità".

Del tipo
```{r}
library(gridExtra)
library(grDevices) # for png saving

clusters_old = NULL
for(time in time_span){

# GRAPH #######################
cat(crayon::red("Time",time,"\n"))
df_cluster_cut = df_cluster[df_cluster$Time==time,]
clusters_now = df_cluster_cut$clusters
clusters_now = mode_correct_clusters(clusters_old,clusters_now)
df_cluster_cut$clusters = clusters_now

	cur_num = sprintf("%02d", time)
	png(filename=paste0("./cluster_plots/test/graph_plot_",cur_num,".png"), width=1000, height=600)
	plot_graph_and_hist(df_cluster_cut)
	dev.off()
	# ggsave(file=paste("./cluster_plots/test/graph_plot_",time,".png"), width=4, height=4, dpi=300)


clusters_old = clusters_now
}
```



# Gif creation in R test
```{r}
# Carica i pacchetti
library(magick)
library(animation)

## list file names and read in
percorso = "./cluster_plots/test/"
imgs <- list.files(path = percorso, pattern = ".png", full.names = TRUE)
img_list <- lapply(imgs, image_read)

## join the images together
img_joined <- image_join(img_list)

## animate at 2 frames per second
img_animated <- image_animate(img_joined, fps = 2)

## view animated image
# img_animated

## save to disk
image_write(image = img_animated,
            path = paste0(percorso,"test.gif"))
```



