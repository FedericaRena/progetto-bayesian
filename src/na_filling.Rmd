---
title: "R Notebook"
output: html_notebook
---

```{r}
source("include.R")
```

```{r}
cat("df_agri shape",size(df_agri),"\n")
cat("df_2018 shape",size(df_2018),"\n")
```

# NA Filling

We have to choose which approach to use:
- historical fill ("if a monday is missing fill it with the mean/median of all mondays")
- temporal interpolation ("if a monday is missing fill it with the mean of sunday and tuesday")

We should inspect the trend to see which approach is better maybe.


```{r}
# add column day (names) on df_2018
days = c("lunedì","martedì","mercoledì","giovedì","venerdì","sabato","domenica")
day_names = weekdays(df_2018$Time)
df_2018$day = as.factor(day_names)
head(df_2018)
```


## Trend inspection - historical fill
```{r}
# cols = colora(7,runif(1,0,133),1)
cols = colora(7,24,0)
st = sample(unique(df_2018$IDStations),1)

for (d in days){
	df_st = df_2018[df_2018$IDStations==st,] # filter a single station
	df_st_day = df_st[df_st$day == d,] # filter a certain day
	
	col_idx = which(days==d)
	if(col_idx==1)
		plot(df_st_day$AQ_pm10,xlab="year weeks",ylab="PM10 values",
			 main=paste("station",st),col=cols[col_idx],type="l")
	else
		points(df_st_day$AQ_pm10,xlab="year weeks",ylab="PM10 values",
			   main=paste("station",st),col=cols[col_idx],type="l")
}
legend("top",c("lunedì","martedì","mercoledì","giovedì","venerdì","sabato","domenica"),
	   fill=cols,cex=0.6,bty = "n")
```

It seems that there is the U trend (high in winter, low in summer), as we already knew.
So maybe averaging does not lead to a good result, as we will put
- "high" values in summer and
- "low" values in winter
as the next plot shows

```{r}
# cols = colora(7,runif(1,0,133),1)
cols = colora(7,24,0)
st = sample(unique(df_2018$IDStations),1)

for (d in days){
	df_st = df_2018[df_2018$IDStations==st,] # filter a single station
	df_st_day = df_st[df_st$day == d,] # filter a certain day
	
	col_idx = which(days==d)
	if(col_idx==1)
		plot(df_st_day$AQ_pm10,xlab="year weeks",ylab="PM10 values",
			 main=paste("station",st),col=cols[col_idx],type="l")
	else
		points(df_st_day$AQ_pm10,xlab="year weeks",ylab="PM10 values",
			   main=paste("station",st),col=cols[col_idx],type="l")
	
	abline(h=mean(na.omit(df_st_day$AQ_pm10)),col=cols[col_idx])
}
legend("top",c("lunedì","martedì","mercoledì","giovedì","venerdì","sabato","domenica"),
	   fill=cols,cex=0.6,bty = "n")
```

## Trend inspection - temporal interpolation, or "intempolation" :)

Now the idea is to see how much variability there is in consequent days.
So we could select a random interval of time and see the trend there.

```{r}
# to not have huge intervals
end_day = 400
while(end_day > 365){
	start_day = round(runif(1, min=0, max=365))
	end_day = start_day + round(runif(1,min=5,max=30))
}

title=paste(end_day-start_day,"days:",
			"from",format(as.Date("2018-01-01")+start_day),
			"to",format(as.Date("2018-01-01")+end_day))

# st = "635"
st = sample(unique(df_2018$IDStations),1)
df_st = df_2018[df_2018$IDStations==st,] # filter a single station
df_st_int = df_st[start_day:end_day,]

plot(df_st_int$Time,df_st_int$AQ_pm10,main=title,type="b")

```


NA visual plot reconstruction:

```{r}
# Chat GPT help :/
interpola_NA <- function(seq) {
  non_na_indices <- which(!is.na(seq))
  na_indices <- which(is.na(seq))
  
  # loop on Na indices
  for (na_index in na_indices) {
    # Trova l'indice più vicino a sinistra e quello più vicino a destra
    left_index <- max(non_na_indices[non_na_indices < na_index])
    right_index <- min(non_na_indices[non_na_indices > na_index])
    
    # Esegui l'interpolazione se ci sono valori a sinistra e a destra
    if (!is.na(left_index) && !is.na(right_index)) {
      left_value <- seq[left_index]
      right_value <- seq[right_index]
      
      # Calcola il valore interpolato
      interpolated_value <- left_value + 
        ((right_value - left_value) / (right_index - left_index)) * (na_index - left_index)
      
      # Sostituisci il valore NA con quello interpolato
      seq[na_index] <- interpolated_value
    }
  }
  return(seq)
}

# example
sequence <- c(10, 15, NA, 20, 24, 20, 18, NA, NA, 10, 9, 9)
print(sequence)
result <- interpola_NA(sequence)
print(round(result))
```

```{r}
plot(df_st_int$Time,df_st_int$AQ_pm10,main=title,type="b",lwd=2)
obs = df_st_int$AQ_pm10
obs_wo_na = interpola_NA(obs)

df_st_int_wo_na = df_st_int
df_st_int_wo_na$AQ_pm10 = obs_wo_na
lines(df_st_int_wo_na$Time,df_st_int_wo_na$AQ_pm10,type="b",lty=2,col="blue")
```
This seems a better choice for NA filling then?



# Week division
```{r}

```




