---
title: "Untitled"
output: html_document
---

# Setup
```{r,warning = FALSE}
library(drpm)
library(salso)

# preparation
source("include.R") # for having df_agri
source("plot functions/plotter.R")

sites = data.frame(
	longitude = unique(df_weekly$Longitude), 
	latitude = unique(df_weekly$Latitude))
```

better to leave this alone (less buggy but dont know why).
```{r}
source("include_clusters_functions.R")
```

create a pm10 table (station x time)
```{r}
stations = unique(df_weekly$IDStations)
y=data.frame()

for(st in stations){
  y_we_pm10=cbind(as.data.frame(st),t(df_weekly[which(df_weekly$IDStations==st),"AQ_pm10"]))
  y=rbind(y,y_we_pm10)
}

rownames(y) = NULL
colnames(y)<- c("id",paste0("w", 1:53))
df_weekly
y
```


```{r}
cols = colora(105,56,show=F)
chosen_variable_name = "AQ_pm10"

trendYearStation_week <- function(file_name){

	data_from_to = df_weekly
	len_time = 54
	
	chosen_variable = (data_from_to[,chosen_variable_name])

	# Crea il grafico ggplot
	station_trend <- ggplot(data_from_to,aes(x = week, 
												 y = AQ_pm10,
												 group=IDStations, 
												 color = as.factor(IDStations))) +
		
		geom_line(show.legend = FALSE) +
		labs(x = "Stations", y = chosen_variable_name, title = "Year: 2018 all stations") +
		ylim(range(na.omit(chosen_variable))) +
		scale_color_manual(values = cols) +
		theme_bw()+
		theme(panel.grid = element_blank()) +
		guides(color = guide_legend())+
		labs(x="week")
	
	len_time = (len_time%/%5)
	return(trend_animator(file_name,station_trend, data_from_to$week,len_time))
}
trendYearStation_week("None")
```

standardize space coordinates
```{r}
std_sites = sites
	
smn <- apply(std_sites,2,mean)
ssd <- apply(std_sites,2,sd)
std_sites <- t((t(std_sites) - smn)/ssd)

sites
std_sites = data.frame(std_sites)
colnames(std_sites) = colnames(sites)
std_sites
```


```{r}
plot(sites)
plot(std_sites,col="blue")
```


# Models fit
```{r}
time_span = 1:8 # low time span for quick testing, real one will be 1:53

### authors suggested to/did scale the spatial locations and also centered the observations
y_fit = y[,1+time_span]
y_fit = scale(y_fit,center=TRUE, scale=FALSE)
y

medie = apply(y[,1+time_span],2,mean)
head(t(t(y[,1+time_span])-medie)) # scale hand computed, to check

y_fit = data.frame(y_fit)
colnames(y_fit) = colnames(y)[1+time_span]

y_fit
tps = ncol(y_fit)
### and for the scaling of spatial locations we already built
std_sites
```


```{r}
# modelPriors = c(m0, s20, Asig, Atau, Alam, a, b, be)
# m0 - mean of theta (or phi0)
# s20 - variance of theta (or phi0)
# Asig - maximum value for sigma
# Atau - maximum value for tau
# Alam - maximum value for lambda
# a - shape 1 for alpha
# b - shape 2 for alpha
# b - scale for eta1
modelPriors <- c(0,100, 10, 5, 5, 2, 2, 1)

# m, k0, nu0, L0
cParms <- c(0,1,5,1)

# SIG, TAU, LAM, ETA1, PHI1
mh <- c(1,1, 1, 0.1, 0.1)
sp <- 4

# niter=50000; nburn=10000; nthin=40 # real one
niter=500; nburn=100; nthin=2 # Fede tests quick one 
nout <- (niter-nburn)/nthin

alpha = 0.0
set.seed(1)
models.out <- list()
hh <- 1
# h <- "111"; s <- "0";
model <- "AR1"
for(s in c("0","1")){
	for(h in c("E1P1A1","E1P1A0","E1P0A1","E1P0A0","E0P1A1","E0P1A0","E0P0A1","E0P0A0")){

		m.n <- as.numeric(strsplit(h, "")[[1]][c(2,4,6)])
		
		eta1_bool <- m.n[1]!=0
		phi1_bool <- m.n[2]!=0
		alpha_bool <- m.n[3]!=0
		# we select true if the number in h was 1, ie "!=0"
		
		if(s=="0"){
			sc <- NULL
		} else {
			sc <- std_sites
		}

		tempo_inizio <- Sys.time()
		set.seed(1*hh)
		out <- drpm_fit(draws=niter, burn=nburn, thin=nthin,
						y=y_fit, M=1,s_coords=sc,
						# global_alpha=FALSE, # forse intendevano questi due comandi dopo:
						unit_specific_alpha=FALSE,
						
						time_specific_alpha=FALSE, # meaning a bit ambiguos
						# Ok after experimenting it means that:
						# - if true we let alpha be a param that changes over time. 
						#	At time 1 we have a chain with some behaviour, 
						#	at time 2 another chain with another behaviour, ecc
						# - if false we instead fix alpha, ie all chains of all times
						#	will be the same, as they refer to the same parameter estimation
						# The authors in their tests set it to false, ie the fixed alpha
	  				
	  					modelPriors=modelPriors,
	  					alpha_0 = alpha_bool,
	  					eta1_0 = eta1_bool,
	  					phi1_0 = phi1_bool,
	  					SpatialCohesion=sp, cParms=cParms,mh=mh)
		
		tempo_fine <- Sys.time()
		cat(crayon::red("##############################\n"))
		cat("Model is",paste0(h,"_S",s),"ie:",
			"\neta1_bool =",eta1_bool,"-",
			"phi1_bool =",phi1_bool,"-",
			"alpha_bool =",alpha_bool,"-",
			"space =",s,
			"\n")
		# cat("seed is", 1*hh, "\n")
		cat("\n")
		differenza_tempo <- tempo_fine - tempo_inizio
		cat("Fit took:\n")
		print(round(differenza_tempo,digits = 4))

		# print(date())
    	cat("lpml = ", out$lpml, "\n")
    	cat("waic = ", out$waic, "\n")
    	cat(crayon::red("##############################\n"))
		models.out[[hh]] <- out
		names(models.out)[hh] <- paste0("out_",h,"_S",s,"_",model)

		rho <- list()

		for(k in 1:tps){
			# rho[[k]] <- salso(t(out$Si[k,,]), loss="VI")
			rho[[k]] <- salso(t(out$Si[k,,]), loss="binder")
		}

		amn <- round(apply(models.out[[hh]]$alpha,2,mean),2)

		# If there is desire to produce plot of each fit uncomment this lines
		### a noi non serve abbiamo già i nostri plot
		
		# pdf(paste0("PM10_", h,"_",s,"_",model,"_SC",sp,"_2.pdf"),height=10, width=12.5)
				# pchs <- c(letters, paste0(letters,0:9))
				# par(mfrow=c(3,4))
				# for(jj in 1:tps){
				# 	cex1 <- ((y_fit[,jj]-mean(y_fit[,jj]))/sd(y_fit[,jj])+3)/3
				# 	plot(s_std, col=rho[[jj]], pch=pchs[rho[[jj]]],cex=cex1,
				# 				main=bquote(alpha==.(amn[jj]) ~~ Time ~ .(jj)),
				# 				ylab="", xlab="")
				# }
		# dev.off()
			
		hh <- hh + 1
	}
}
```


# Table 3
WAIC and LPML values.

```{r}
# Create table that contains the WAIC and LPML values
lpml <-  waic <- numeric()
amn <- matrix(NA, nrow = length(models.out), ncol=ncol(y_fit))
for(j in 1:length(models.out)){
	lpml[j] <- models.out[[j]]$lpml
  # lpmlr[j] <- lpml.robust(models.out[[j]]$llike)
	waic[j] <- models.out[[j]]$waic
	amn[j,] <- round(apply(models.out[[j]]$alpha,2,mean),2)
}
res <- data.frame(names=names(models.out), lpml=lpml, waic=waic)
res[order(res[,2]),]

# xtable(res[order(res[,2]),],digits=2) # for latex table generation
```
```{r}
ordered_names = res$names[order(res[,2])]
order_best = order(res[,2])

s0_order = c()
for (i in order_best){
	if(length(grep("S0",res$names[i],value=TRUE))>=1){
		s0_order = c(s0_order,i) 	
	}
}
s0_order

s1_order = c()
for (i in order_best){
	if(length(grep("S1",res$names[i],value=TRUE))>=1){
		s1_order = c(s1_order,i) 	
	}
}
s1_order

```



# Figure 5
Lagged ARI plots for models that include time BUT NOT space.

```{r,warning=FALSE}
library(fields)
library(salso)
library(drpm)
library(MCMCpack)
library(mclust)
library(gstat)

# Compute the lagged partitions for all 16 models
ARImats <- vector("list", length(models.out))
for (i in 1:length(models.out)) {
  ARImats[[i]] <- matrix(NA, nrow=tps, ncol=tps)
}

for(h in 1:length(models.out)){
	for(k in 1:tps){
		rho[[k]] <- salso(t(models.out[[h]]$Si[k,,]), loss="binder")
	}

	for(k in 1: tps){
		for(kk in 1: tps){
			ARImats[[h]][k,kk] <- adjustedRandIndex(rho[[k]], rho[[kk]])
		}
	}
}

pch=as.character(1:nrow(y))

# This is Figure 5 in the paper. 
# Lagged ARI plots for models that include time only (no space)
ord2 = s0_order

# pdf(paste0("LaggedARI_NoSpace2.pdf"), height=7, width=13)

	par(mfrow=c(2,4),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
	for(h in ord2){
		m.n <- as.numeric(do.call(c, strsplit(strsplit(names(models.out)[h], "t|\\_")
											  [[1]][c(2,3)], ""))[c(2,4,6)])
		header <- bquote(eta[1]*  .(ifelse(m.n[1]==1,":Yes",":No"))*","~
	    	             phi[1]*  .(ifelse(m.n[2]==1,":Yes",":No"))*","~
	        	         alpha[t]*.(ifelse(m.n[3]==1,":Yes",":No")))
		image.plot(ARImats[[h]], main=header, zlim=range(do.call(c,ARImats),na.rm=TRUE), axes=FALSE)
		mtext(text=c(paste("",1:tps)), side=2, line=0.3,
			  at=seq(0,1,length=max(time_span)), las=1, cex=0.8)
		mtext(text=c(paste("",1:tps)), side=1, line=0.3,
			  at=seq(0,1,length=max(time_span)), las=2, cex=0.8)
	}
# dev.off()
```

Figure 6
Questa non ci interessa/piace, anche perché noi abbiamo molte più stazioni quindi quel plot uscirebbe molto incasinato. E poi abbiamo già i nostri plot.


# Figure 7
Lagged ARI plots for models that include time AND space.

```{r,warning=FALSE}
# This is Figure 7 in the paper.
# Lagged-ARI plots for models that include space in the partition
ord2 <- s1_order

# pdf(paste0("LaggedARI_OnlySpace2.pdf"), height=7, width=13)

	par(mfrow=c(2,4),mar=c(2,2,2,2), mgp=c(1.5,0.5,0))
	for(h in ord2){
		m.n <- as.numeric(do.call(c, strsplit(strsplit(names(models.out)[h], "t|\\_")
											  [[1]][c(2,3)], ""))[c(2,4,6)])
		header <- bquote(eta[1]*  .(ifelse(m.n[1]==1,"-Yes","-No"))*","~
	    	             phi[1]*  .(ifelse(m.n[2]==1,"-Yes","-No"))*","~
	        	         alpha[t]*.(ifelse(m.n[3]==1,"-Yes","-No")))
		image.plot(ARImats[[h]], main=header, zlim=range(do.call(c,ARImats),na.rm=TRUE), axes=FALSE)
		mtext(text=c(paste("",1:tps)), side=2, line=0.3,
			  at=seq(0,1,length=max(time_span)), las=1, cex=0.8)
		mtext(text=c(paste("",1:tps)), side=1, line=0.3,
			  at=seq(0,1,length=max(time_span)), las=2, cex=0.8)
	}
# dev.off()
```


