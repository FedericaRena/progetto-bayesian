---
title: "R Notebook"
output: html_notebook
---
```{r}
source("include.R") 
```

```{r}
library(CARBayesST)
library(sp)
library(proxy)
library(coda)
```
```{r}
head(df_wsc)
```
# ORDER BY TIME
The values in each column of these matrices should be ordered so that the first K data points are the set of all K spatial locations at time1, the next K are the set of spatial locations for time 2 and so on.
```{r}
ordered_by_time <- df_wsc[order(df_wsc$Time), ]
head(ordered_by_time)
```
# SET COVARIATES
```{r}
colnames(ordered_by_time)
covariates_to_exclude = c("X","IDStations",
						  "Latitude","Longitude","Time","day","week"
						  )
covariates=ordered_by_time[,-which(colnames(ordered_by_time)%in% covariates_to_exclude)]

head(covariates)
```

# neighbourhood matrix
```{r}
spatial_coord = ordered_by_time[ordered_by_time$Time=="2018-01-01",c("IDStations","Latitude","Longitude")]
head(spatial_coord)

coordinates(spatial_coord) <- c("Longitude", "Latitude")

# Calculate the pairwise Euclidean distance matrix
dist_matrix <- as.matrix(proxy::dist(coordinates(spatial_coord), method = "Euclidean"))
dim(dist_matrix)
formula = as.formula("AQ_pm10~.")
```
# LINEAR
```{r}
mod_linear<-ST.CARlinear(formula= formula,
		   family = "gaussian",
		   data=covariates,
		   W= dist_matrix,
		   burnin = 1000,
		   n.sample = 25000,
		   thin=10, 
		   n.chains=1, 
		   n.cores=1,
		   prior.mean.beta=NULL,
		   prior.var.beta=NULL,
		   prior.mean.alpha=NULL,
		   prior.var.alpha=NULL,
		   prior.nu2=NULL, 
		   prior.tau2=NULL,
		   rho.slo=NULL,
		   rho.int=NULL,
		   MALA=TRUE,
		   verbose=TRUE)

```
# AR
```{r}
mod_AR1<-ST.CARar(formula= formula,
		   family = "gaussian",
		   data=covariates,
		   W= dist_matrix,
		   burnin = 1000,
		   n.sample = 25000,
		   thin=10,  
		   n.chains=1, 
		   n.cores=1,
		   prior.mean.beta=NULL,
		   prior.var.beta=NULL,
		   prior.nu2=NULL, 
		   AR=1, #1 or 2
		   rho.S=NULL,
		   rho.T=NULL, 
		   MALA=TRUE,
		   verbose=TRUE)

mod_AR2<-ST.CARar(formula= formula,
		   family = "gaussian",
		   data=covariates,
		   W= dist_matrix,
		   burnin = 1000,
		   n.sample = 25000,
		   thin=10,  
		   n.chains=1, 
		   n.cores=1,
		   prior.mean.beta=NULL,
		   prior.var.beta=NULL,
		   prior.nu2=NULL, 
		   AR=2, #1 or 2
		   rho.S=NULL,
		   rho.T=NULL, 
		   MALA=TRUE,
		   verbose=TRUE)
```

# ADAPTIVE AR sloooooooow
2 hours (10,1000,1)
```{r}
mod_ARadaptive<-ST.CARadaptive(formula= formula,
		   family = "gaussian",
		   data=covariates,
		   W= dist_matrix,
		   burnin = 10,
		   n.sample = 1000,
		   thin=1, 
		   prior.mean.beta=NULL,
		   prior.var.beta=NULL,
		   prior.nu2=NULL, 
		   prior.tau2=NULL,
		   rho=NULL,
		   epsilon=0,
		   MALA=TRUE,
		   verbose=TRUE)
```



# ST.CARlocalised, ST.CARsepspatial, CLUSTERends: 
only binomial or poisson: response must be integer valued
seems useless for our goal
divide into groups low medium high?
```{r}
model_list = list(mod_linear,mod_AR1,mod_AR2,mod_ARadaptive)
mod = model_list[[4]]
```


# MCMC analysis

## samples
```{r}
summary(mod$samples)
```

## mcmc plots
### betas
```{r}
mcmc_matrix = as.matrix(mod$samples$beta)
for(i in 1:dim(mcmc_matrix)[2]){
	plot(mcmc_matrix[,i],type="l",cex.axis=0.8)
}
```
```{r}
mcmc_matrix = as.matrix(mod$samples$rho)
for(i in 1:dim(mcmc_matrix)[2]){
	plot(mcmc_matrix[,i],type="l",cex.axis=0.8)
}
```

# print the model
```{r}
print(mod)
```

```{r}
summary_results = mod$summary.results
summary_results = data.frame(summary_results)
# Identify variables with credible intervals excluding zero
selected_variables <- summary_results[summary_results$X2.5. > 0 | summary_results$X97.5. < 0, ]

print(selected_variables)

```

# coefficents
```{r}
coef(mod)
```
# acceptance probabilities
```{r}
mod$accept
```
# metrics
```{r}
metrics_dataframe = data.frame()
for( mod in model_list)
	print(mod$modelfit)
```



# residuals
```{r}
resid = residuals(mod)
plot(resid,type="l")
```





# Example of ANOVA: could be used to evaluate the clusterings! 		
```{r}
# Load required libraries
library(MASS)  # For mvrnorm function (multivariate normal distribution)
library(spdep) # For spatial dependency functions
library(stats)  # For kronecker function

# Setup the regular lattice
x.easting <- 1:10
x.northing <- 1:10
Grid <- expand.grid(x.easting, x.northing)
K <- nrow(Grid)
N <- 10
N.all <- N * K

# Setup spatial (W) and temporal (D) neighbourhood matrices
distance <- as.matrix(dist(Grid))
W <- array(0, c(K, K))
W[distance == 1] <- 1

D <- array(0, c(N, N))
for (i in 1:N) {
  for (j in 1:N) {
    if (abs((i - j)) == 1) D[i, j] <- 1
  }
}

# Simulate the elements in the linear predictor and the data
gamma <- rnorm(n = N.all, mean = 0, sd = 0.001)
x <- rnorm(n = N.all, mean = 0, sd = 1)
beta <- 0.1

Q.W <- 0.99 * (diag(apply(W, 2, sum)) - W) + 0.01 * diag(rep(1, K))
Q.W.inv <- solve(Q.W)
phi <- mvrnorm(n = 1, mu = rep(0, K), Sigma = (0.01 * Q.W.inv))

Q.D <- 0.99 * (diag(apply(D, 2, sum)) - D) + 0.01 * diag(rep(1, N))
Q.D.inv <- solve(Q.D)
delta<-mvrnorm(n=1,mu=rep(0,N),Sigma=(0.01*Q.D.inv))
phi.long <- rep(phi, N)
delta.long <- kronecker(delta, rep(1, K))

LP <- 4 + x * beta + phi.long + delta.long + gamma
mean <- exp(LP)
Y <- rpois(n = N.all, lambda = mean)

# Run the model (commented out for now)
mod <- ST.CARanova(formula = Y ~ x, family = "poisson", interaction = TRUE, W = W, burnin = 10, n.sample = 50)
summary(model)
model$summary.results
```



